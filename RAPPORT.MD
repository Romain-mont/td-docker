# Rapport de Synth√®se : Application Conteneuris√©e

Ce projet pr√©sente une architecture compl√®te (Full Stack) conteneuris√©e respectant les bonnes pratiques DevOps modernes : images l√©g√®res, s√©curit√©, orchestration et automatisation.

---

## 1. Architecture du Projet

L'application est compos√©e de trois services interconnect√©s, isol√©s dans un r√©seau priv√© Docker (`app-network`).

### Sch√©ma de communication

```
Utilisateur (Navigateur) ‚û°Ô∏è Frontend (Nginx :8080) ‚û°Ô∏è API (Node.js :3000) ‚û°Ô∏è Base de Donn√©es (PostgreSQL :5432)
```

### Description des services

#### Frontend (projet-front)

- Application statique g√©n√©r√©e avec **Vite** (Vanilla JS)
- Servie par un serveur **Nginx** (Alpine) configur√© en Reverse Proxy
- **R√¥le** : Sert l'interface utilisateur et redirige les requ√™tes commen√ßant par `/api/` vers le conteneur API. Cela permet d'√©viter les probl√®mes de CORS et de masquer l'adresse r√©elle de l'API.

#### API (projet-api)

- D√©velopp√©e en **Node.js** avec **Express**
- Connect√©e √† la base de donn√©es via le module `pg`
- **S√©curit√©** : Ce conteneur n'expose aucun port sur la machine h√¥te. Il est accessible uniquement par le Frontend via le r√©seau Docker interne, garantissant une isolation totale.

#### Base de Donn√©es (projet-db)

- **PostgreSQL 15** (version Alpine l√©g√®re)
- Les donn√©es sont persist√©es gr√¢ce √† un volume Docker nomm√© (`db_data`)
- Initialis√©e automatiquement au premier d√©marrage via un script SQL (`init.sql`)

---

## 2. Commandes Cl√©s et Automatisation

Pour simplifier le d√©ploiement , un script d'automatisation `deploy.sh` a √©t√© cr√©√©.

### Lancement rapide

L'ensemble du projet se lance avec une seule commande :

```bash
./deploy.sh
```

Ce script effectue automatiquement les actions suivantes :

1. **Configuration** : D√©tecte l'absence de fichier `.env` et le g√©n√®re √† partir de `.env.example` (gestion des secrets)
2. **Build** : Construit les images Docker en for√ßant la mise √† jour (`docker compose build`)
3. **D√©ploiement** : Lance la stack en mode d√©tach√© (`docker compose up -d`)

### Autres commandes utiles

- V√©rifier les logs : `docker compose logs -f`
- Arr√™ter la stack : `docker compose down`
- V√©rifier l'utilisateur (S√©curit√©) : `docker exec projet-api whoami` (Doit retourner `node`)

---

## 3. Bonnes Pratiques Mises en ≈íuvre

Ce projet a √©t√© con√ßu pour maximiser la s√©curit√© et la performance, conform√©ment aux exigences du TD.

### üê≥ Optimisation des Images (Multistage Builds)

Nous utilisons la construction multi-√©tapes pour l'API et le Frontend.

- **Frontend** : Une √©tape `node` build le code , puis seule l'archive finale est copi√©e dans une image `nginx:alpine`. Le code source et les `node_modules` ne sont pas dans l'image finale.
- **API** : Une √©tape installe les d√©pendances, puis une image finale ne copie que le n√©cessaire de production.

**R√©sultat** : Des images beaucoup plus l√©g√®res et une surface d'attaque r√©duite.

### üîí S√©curit√© (User Non-Root)

Par d√©faut, les conteneurs tournent en root, ce qui est une faille de s√©curit√©.

- Nous avons configur√© explicitement `USER node` dans le Dockerfile de l'API
- L'isolation r√©seau emp√™che l'acc√®s direct √† la base de donn√©es ou √† l'API depuis l'ext√©rieur

### ‚öôÔ∏è Orchestration et Robustesse

- **Healthchecks** : Le service `db` poss√®de un healthcheck (`pg_isready`). L'API attend que la base soit "saine" (`service_healthy`) avant de d√©marrer, √©vitant les crashs au lancement.
- **Environment Variables** : Aucune configuration sensible n'est √©crite "en dur". Tout est inject√© via le fichier `.env` g√©r√© par Docker Compose.
- **.dockerignore** : Configuration stricte pour ne pas copier les fichiers locaux (`node_modules`, `.env`, `.git`) dans les conteneurs.

---